{"version":3,"file":"index.d.ts","sources":["index.d.ts"],"names":[],"mappings":"AAAA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { AwesomeCordovaNativePlugin } from '@awesome-cordova-plugins/core';\nimport { Observable } from 'rxjs';\nexport declare type Status = 'scanStarted' | 'scanStopped' | 'scanResult' | 'connected' | 'disconnected' | 'bonding' | 'bonded' | 'unbonded' | 'closed' | 'services' | 'discovered' | 'characteristics' | 'descriptors' | 'read' | 'subscribed' | 'unsubscribed' | 'subscribedResult' | 'written' | 'readDescriptor' | 'writeDescriptor' | 'rssi' | 'mtu' | 'connectionPriorityRequested' | 'enabled' | 'disabled' | 'readRequested' | 'writeRequested' | 'mtuChanged' | 'notifyReady' | 'notifySent' | 'serviceAdded' | 'serviceRemoved' | 'allServicesRemoved' | 'advertisingStarted' | 'advertisingStopped' | 'responded' | 'notified' | 'notificationSent';\n/** Available connection priorities */\nexport declare type ConnectionPriority = 'low' | 'balanced' | 'high';\nexport interface Params {\n    /** The address/identifier provided by the scan's return object */\n    address: string;\n    /** The service's ID */\n    service: string;\n}\nexport interface InitPeripheralParams {\n    /** Should user be prompted to enable Bluetooth */\n    request?: boolean;\n    restoreKey?: string;\n}\nexport interface InitParams extends InitPeripheralParams {\n    /** Should change in Bluetooth status notifications be sent */\n    statusReceiver?: boolean;\n}\nexport interface ScanParams {\n    services?: string[];\n    allowDuplicates?: boolean;\n    /** Defaults to Low Power. Available from API21 / API 23 (Android) */\n    scanMode?: BluetoothScanMode;\n    /** Defaults to Aggressive. Available from API23 (Android) */\n    matchMode?: BluetoothMatchMode;\n    /** Defaults to One Advertisement. Available from API23 (Android) */\n    matchNum?: BluetoothMatchNum;\n    /** Defaults to All Matches. Available from API21 / API 23. (Android) */\n    callbackType?: BluetoothCallbackType;\n    /** True/false to show only connectable devices, rather than all devices ever seen, defaults to false (Windows) */\n    isConnectable?: boolean;\n}\nexport interface NotifyParams {\n    /** Service's UUID */\n    service: string;\n    /** Characteristic's UUID */\n    characteristic: string;\n    /** Base64 encoded string, number or string */\n    value: string;\n    /** Android only: address of the device the notification should be sent to. */\n    address?: string;\n}\nexport interface RespondParams {\n    /** This integer value will be incremented every read/writeRequested */\n    requestId: number;\n    /** base64 string */\n    value: string;\n    /** not documented */\n    offset?: number;\n}\nexport interface ConnectionParams {\n    /** The address/identifier provided by the scan's return object */\n    address: string;\n    /** Automatically connect as soon as the remote device becomes available (Android) */\n    autoConnect?: boolean;\n    /**\n     * Transport mode. Available from API 23 (Android).\n     * If none is specified the default behavior is TRANSPORT_AUTO\n     *\n     * Note: On Android 10, TRANSPORT_AUTO can lead to connection errors with Status code 133.\n     * In this case TRANSPORT_LE can be used.\n     */\n    transport?: AndroidGattTransportMode;\n}\nexport declare enum AndroidGattTransportMode {\n    /**\n     * No preference of physical transport for GATT connections to remote dual-mode devices\n     */\n    TRANSPORT_AUTO = 0,\n    /**\n     * Prefer BR/EDR transport for GATT connections to remote dual-mode devices\n     */\n    TRANSPORT_BREDR = 1,\n    /**\n     * Prefer LE transport for GATT connections to remote dual-mode devices\n     */\n    TRANSPORT_LE = 2\n}\nexport interface CharacteristicParams extends Params {\n    /** An array of characteristic IDs to discover or empty array / null */\n    characteristics?: string[];\n}\nexport interface DescriptorParams extends Params {\n    /** The characteristic's ID */\n    characteristic: string;\n}\nexport interface OperationDescriptorParams extends DescriptorParams {\n    /** The descriptor's ID */\n    descriptor: string;\n}\nexport interface WriteCharacteristicParams extends DescriptorParams {\n    value: string;\n    type?: string;\n}\nexport interface WriteDescriptorParams extends DescriptorParams {\n    /** The descriptor's ID */\n    descriptor: string;\n    /** Base64 encoded string, number or string */\n    value: string;\n}\nexport declare type AdvertisingParams = AdvertisingParamsAndroid | AdvertisingParamsIOS;\nexport declare type AdvertiseMode = 'balanced' | 'lowLatency' | 'lowPower';\nexport declare type TxPowerLevel = 'high' | 'low' | 'ultralow' | 'medium';\nexport interface AdvertisingParamsAndroid {\n    /** Service UUID on Android */\n    service: string;\n    /** not documented */\n    mode?: AdvertiseMode;\n    /** not documented */\n    connectable?: boolean;\n    /** not documented */\n    timeout?: number;\n    /** not documented */\n    txPowerLevel?: TxPowerLevel;\n    /** not documented */\n    manufacturerId?: number;\n    /** not documented */\n    manufacturerSpecificData?: any;\n    /** not documented */\n    includeDeviceName: boolean;\n    /** not documented */\n    includeTxPowerLevel: boolean;\n}\nexport interface AdvertisingParamsIOS {\n    /** Array of service UUIDs on iOS */\n    services: string[];\n    /** device's name */\n    name?: string;\n}\nexport interface CommonInfo {\n    /** The device's display name */\n    name: string;\n    /** The device's address / identifier for connecting to the object */\n    address: string;\n}\nexport interface DeviceInfo extends CommonInfo {\n    /** Device's status */\n    status: Status;\n}\nexport interface RSSI extends DeviceInfo {\n    /** signal strength */\n    rssi: number;\n}\nexport interface MTU extends DeviceInfo {\n    mtu: number;\n}\nexport interface BondedStatus extends CommonInfo {\n    isBonded: boolean;\n}\nexport interface PrevConnectionStatus extends CommonInfo {\n    /** Determine whether the device was connected */\n    wasConnected: boolean;\n}\nexport interface CurrConnectionStatus extends CommonInfo {\n    /** Determine whether the device is connected */\n    isConnected: boolean;\n}\nexport interface DiscoverStatus extends CommonInfo {\n    /** Determine whether the device's characteristics and descriptors have been discovered */\n    isDiscovered: boolean;\n}\nexport interface ScanStatus extends DeviceInfo {\n    /** signal strength */\n    rssi: number;\n    /**\n     * advertisement data in encoded string of bytes, use bluetoothle.encodedStringToBytes() (Android)\n     * advertisement hash with the keys (iOS)\n     * empty (Windows)\n     */\n    advertisement: {\n        /** An array of service UUIDs */\n        serviceUuids: string[];\n        /** A string representing the name of the manufacturer of the device */\n        manufacturerData: string;\n        /** A number containing the transmit power of a peripheral */\n        txPowerLevel: number;\n        /** An array of one or more CBUUID objects, representing CBService UUIDs that were found in the “overflow” area of the advertisement data */\n        overflowServiceUuids: string[];\n        /** A boolean value that indicates whether the advertising event type is connectable */\n        isConnectable: boolean;\n        /** An array of one or more CBUUID objects, representing CBService UUIDs */\n        solicitedServiceUuids: string[];\n        serviceData: any;\n        localName: string;\n    } | string;\n}\nexport interface Service {\n    /** Service's uuid */\n    uuid: string;\n    /** Array of characteristics */\n    characteristics: Characteristic[];\n}\nexport interface Characteristic {\n    descriptors?: Descriptor[];\n    /**  Characteristic's uuid */\n    uuid: string;\n    /**\n     *  Characteristic's properties\n     *  If the property is defined as a key, the characteristic has that property\n     */\n    properties?: {\n        write?: boolean;\n        broadcast?: boolean;\n        extendedProps?: boolean;\n        writeWithoutResponse?: boolean;\n        writeNoResponse?: boolean;\n        signedWrite?: boolean;\n        read?: boolean;\n        notify?: boolean;\n        indicate?: boolean;\n        authenticatedSignedWrites?: boolean;\n        notifyEncryptionRequired?: boolean;\n        indicateEncryptionRequired?: boolean;\n    };\n    /**\n     *  If the permission is defined as a key, the character has that permission\n     */\n    permissions?: {\n        read?: boolean;\n        readEncrypted?: boolean;\n        readEncryptedMITM?: boolean;\n        write?: boolean;\n        writeSigned?: boolean;\n        writeSignedMITM?: boolean;\n        writeEncryptedMITM?: boolean;\n        readEncryptionRequired?: boolean;\n        writeEncryptionRequired?: boolean;\n    };\n}\nexport interface Descriptor {\n    uuid: string;\n}\nexport interface Device extends DeviceInfo {\n    /** Device's services */\n    services: Service[];\n}\nexport interface Services extends DeviceInfo {\n    /** Array of service UUIDS */\n    services: string[];\n}\nexport interface Descriptors extends DeviceInfo {\n    /** Characteristic's UUID */\n    characteristic: string;\n    /** Service's UUID */\n    service: string;\n    descriptors: string[];\n}\nexport interface OperationResult extends DeviceInfo {\n    /** Characteristic UUID */\n    characteristic: string;\n    /** Service's UUID */\n    service: string;\n    /** Base64 encoded string of bytes */\n    value: string;\n}\nexport interface UnsubscribeResult extends DeviceInfo {\n    /** Characteristic UUID */\n    characteristic: string;\n    /** Service's UUID */\n    service: string;\n}\nexport interface DescriptorResult extends OperationResult {\n    descriptor: string;\n}\nexport interface Characteristics extends DeviceInfo {\n    /** Service's id */\n    service: string;\n    characteristics: Characteristic[];\n}\nexport interface InitializeResult {\n    /** Device's status */\n    status: Status;\n    /** The address/identifier provided by the scan's return object */\n    address: string;\n    /** Service's UUID */\n    service: string;\n    /** Characteristic UUID */\n    characteristic: string;\n    /** This integer value will be incremented every read/writeRequested */\n    requestId: number;\n    /** Offset value */\n    offset: number;\n    /** mtu value */\n    mtu: number;\n    /** Base64 encoded string of bytes */\n    value: string;\n}\nexport declare enum BluetoothScanMode {\n    SCAN_MODE_OPPORTUNISTIC = -1,\n    SCAN_MODE_LOW_POWER = 0,\n    SCAN_MODE_BALANCED = 1,\n    SCAN_MODE_LOW_LATENCY = 2\n}\nexport declare enum BluetoothMatchMode {\n    MATCH_MODE_AGRESSIVE = 1,\n    MATCH_MODE_STICKY = 2\n}\nexport declare enum BluetoothMatchNum {\n    MATCH_NUM_ONE_ADVERTISEMENT = 1,\n    MATCH_NUM_FEW_ADVERTISEMENT = 2,\n    MATCH_NUM_MAX_ADVERTISEMENT = 3\n}\nexport declare enum BluetoothCallbackType {\n    CALLBACK_TYPE_ALL_MATCHES = 1,\n    CALLBACK_TYPE_FIRST_MATCH = 2,\n    CALLBACK_TYPE_MATCH_LOST = 4\n}\nexport interface Error {\n    code: number;\n    message: string;\n}\nexport interface AdapterInfo {\n    name: string;\n    address: string;\n    isInitialized: boolean;\n    isEnabled: boolean;\n    isScanning: boolean;\n    isDiscoverable: boolean;\n}\n/**\n * @name BluetoothLE\n * @description\n * This plugin has the most complete implementation for interacting with Bluetooth LE devices on Android, iOS and partially Windows.\n * It's a wrap around [randdusing/cordova-plugin-bluetoothle](https://github.com/randdusing/cordova-plugin-bluetoothle/blob/master/readme.md) cordova plugin for Ionic.\n * It supports peripheral **and** central modes and covers most of the API methods available on Android and iOS.\n * @usage\n * ```typescript\n * import { BluetoothLE } from '@awesome-cordova-plugins/bluetooth-le/ngx';\n *\n *\n * constructor(public bluetoothle: BluetoothLE, public plt: Platform) {\n *\n *  this.plt.ready().then((readySource) => {\n *\n *    console.log('Platform ready from', readySource);\n *\n *    this.bluetoothle.initialize().then(ble => {\n *      console.log('ble', ble.status) // logs 'enabled'\n *    });\n *\n *   });\n * }\n *\n * ```\n */\nexport declare class BluetoothLE extends AwesomeCordovaNativePlugin {\n    /**\n     * @name initialize\n     * Initialize Bluetooth on the device\n     * @param {InitParams} [params]\n     * @returns {(Observable<{ status: 'enabled' | 'disabled'}>)} The callback that is passed initialize status (enabled/disabled)\n     */\n    initialize(params?: InitParams): Observable<{\n        status: 'enabled' | 'disabled';\n    }>;\n    /**\n     * @name enable (Android)\n     * Enable Bluetooth on the device. Android support only\n     * @returns void\n     */\n    enable(): void;\n    /**\n     * @name disable (Android)\n     * Disable Bluetooth on the device. Android support only\n     * @returns void\n     */\n    disable(): void;\n    /**\n     * @name getAdapterInfo (Android)\n     * Retrieve useful information such as the address, name, and various states (initialized, enabled, scanning, discoverable).\n     * This can be very useful when the general state of the adapter has been lost, and we would otherwise need to go through a series of callbacks to get the correct state (first initialized, then enabled, then isScanning, and so forth).\n     * The result of this method allows us to take business logic decisions while avoiding a large part of the callback hell.\n     * Currently the discoverable state does not have any relevance because there is no \"setDiscoverable\" functionality in place. That may change in the future.\n     * @returns {Promise<AdapterInfo>}\n     */\n    getAdapterInfo(): Promise<AdapterInfo>;\n    /**\n     * @name startScan\n     * Scan for Bluetooth LE devices.\n     * Since scanning is expensive, stop as soon as possible. The Cordova app should use a timer to limit the scan interval.\n     * Android API >= 23 requires ACCESS_COARSE_LOCATION permissions to find unpaired devices.\n     * Permissions can be requested by using the hasPermission and requestPermission functions.\n     * Android API >= 23 also requires location services to be enabled. Use isLocationEnabled to determine whether location services are enabled.\n     * If not enabled, use requestLocation to prompt the location services settings page.\n     * @param {ScanParams} params Scan params\n     * @returns {(Observable< ScanStatus >)}\n     */\n    startScan(params: ScanParams): Observable<ScanStatus>;\n    /**\n     * @name stopScan\n     * Stop scan for Bluetooth LE devices. Since scanning is expensive, stop as soon as possible\n     * The app should use a timer to limit the scanning time.\n     * @returns {Promise<{status: 'scanStopped'}>}\n     */\n    stopScan(): Promise<{\n        status: 'scanStopped';\n    }>;\n    /**\n     * @name retrieveConnected\n     * @param params\n     * @param params.services\n     * Retrieved paired Bluetooth LE devices. In iOS, devices that are \"paired\" to will not return during a normal scan.\n     * Callback is \"instant\" compared to a scan.\n     * @param {{ services: string[] }} An array of service IDs to filter the retrieval by. If no service IDs are specified, no devices will be returned.\n     * @returns {Promise<{ devices: DeviceInfo[] }>}\n     */\n    retrieveConnected(params?: {\n        services?: string[];\n    }): Promise<{\n        devices: DeviceInfo[];\n    }>;\n    /**\n     * @name bond (Android)\n     * @param params.address\n     * Bond with a device.\n     * The device doesn't need to be connected to initiate bonding. Android support only.\n     * @param {{ address: string }} params The address/identifier provided by the scan's return object\n     * @returns {(Observable<{ status: DeviceInfo }>)}\n     * success:\n     *    The first success callback should always return with status == bonding.\n     *    If the bond is created, the callback will return again with status == bonded.\n     *    If the bonding popup is canceled or the wrong code is entered, the callback will return again with status == unbonded.\n     * error:\n     *    The callback that will be triggered when the bond operation fails\n     */\n    bond(params: {\n        address: string;\n    }): Observable<{\n        status: DeviceInfo;\n    }>;\n    /**\n     * @name unbond (Android)\n     * @param params.address\n     * Unbond with a device. The device doesn't need to be connected to initiate bonding. Android support only.\n     * @param {{address: string}} params The address/identifier\n     * @returns {Promise<{ status: DeviceInfo }>}\n     *    success: The success callback should always return with status == unbonded, that is passed with device object\n     *    error: The callback that will be triggered when the unbond operation fails\n     */\n    unbond(params: {\n        address: string;\n    }): Promise<{\n        status: DeviceInfo;\n    }>;\n    /**\n     * @name connect\n     * Connect to a Bluetooth LE device\n     * @param connectSuccess The success callback that is passed with device object\n     * @param connectError   The callback that will be triggered when the connect operation fails\n     * @param params         The connection params\n     * @param {ConnectionParams} params\n     * @returns {(Observable<{ status: DeviceInfo }>)}\n     *    success: device object with status\n     *    error: The callback that will be triggered when the unbond operation fails\n     */\n    connect(params: ConnectionParams): Observable<DeviceInfo>;\n    /**\n     * @name reconnect\n     * @param params.address\n     * Reconnect to a previously connected Bluetooth device\n     * @param {{address: string}} params The address/identifier\n     * @returns {(Observable<DeviceInfo>)}\n     */\n    reconnect(params: {\n        address: string;\n    }): Observable<DeviceInfo>;\n    /**\n     * @name disconnect\n     * @param params.address\n     * Disconnect from a Bluetooth LE device.\n     *              Note: It's simpler to just call close(). Starting with iOS 10, disconnecting before closing seems required!\n     * @param {{address: string}} params The address/identifier\n     * @returns {Promise<DeviceInfo>}\n     */\n    disconnect(params: {\n        address: string;\n    }): Promise<DeviceInfo>;\n    /**\n     * @name close\n     * @param params.address\n     * Close/dispose a Bluetooth LE device.\n     * Prior to 2.7.0, you needed to disconnect to the device before closing, but this is no longer the case.\n     * Starting with iOS 10, disconnecting before closing seems required!\n     * @param {{ address: string }} params The address/identifier\n     * @returns {Promise<DeviceInfo>}\n     */\n    close(params: {\n        address: string;\n    }): Promise<DeviceInfo>;\n    /**\n     * @name discover\n     * @param params.address\n     * @param params.clearCache\n     * Discover all the devices services, characteristics and descriptors.\n     * Doesn't need to be called again after disconnecting and then reconnecting.\n     * If using iOS, you shouldn't use discover and services/characteristics/descriptors on the same device.\n     * There seems to be an issue with calling discover on iOS8 devices, so use with caution.\n     * On some Android versions, the discovered services may be cached for a device.\n     * Subsequent discover events will make use of this cache.\n     * If your device's services change, set the clearCache parameter to force Android to re-discover services.\n     * @param {{ address: string, clearCache: boolean }} params The address/identifier\n     * @returns {Promise<Device>}\n     *    success: device object (contains array of service objects)\n     *    error: The callback that will be triggered when the unbond operation fails\n     */\n    discover(params: {\n        address: string;\n        clearCache?: boolean;\n    }): Promise<Device>;\n    /**\n     * @name services (iOS)\n     * @param params.address\n     * @param params.services\n     * Discover the device's services.\n     * Not providing an array of services will return all services and take longer to discover. iOS support only.\n     * @param {{address: string, services: string[]}} params\n     * @returns {Promise<Services>}\n     */\n    services(params: {\n        address: string;\n        services?: string[];\n    }): Promise<Services>;\n    /**\n     * @name characteristics (iOS)\n     * Discover the service's characteristics.\n     * Not providing an array of characteristics will return all characteristics and take longer to discover. iOS support only.\n     * @param {CharacteristicParams} params Characteristic params\n     * @returns {Promise<{ characteristics: Characteristics }>} The service id and an Array of characteristics\n     */\n    characteristics(params: CharacteristicParams): Promise<{\n        characteristics: Characteristics;\n    }>;\n    /**\n     * @name descriptors (iOS)\n     * Discover the characteristic's descriptors. iOS support only.\n     * @param {DescriptorParams} params\n     * @returns {Promise<{ descriptors: Descriptors }>}\n     */\n    descriptors(params: DescriptorParams): Promise<{\n        descriptors: Descriptors;\n    }>;\n    /**\n     * @name read\n     * Read a particular service's characteristic once\n     * @param {DescriptorParams} params\n     * @returns {Promise<OperationResult>}\n     */\n    read(params: DescriptorParams): Promise<OperationResult>;\n    /**\n     * @name subscribe\n     * Subscribe to a particular service's characteristic.\n     * Once a subscription is no longer needed, execute unsubscribe in a similar fashion.\n     * The Client Configuration descriptor will automatically be written to enable notification/indication based on the characteristic's properties.\n     * @param {DescriptorParams} params\n     * @returns {Observable<OperationResult>}\n     */\n    subscribe(params: DescriptorParams): Observable<OperationResult>;\n    /**\n     * @name unsubscribe\n     * Unsubscribe to a particular service's characteristic.\n     * @param {DescriptorParams} params\n     * @returns {Promise<UnsubscribeResult>}\n     */\n    unsubscribe(params: DescriptorParams): Promise<UnsubscribeResult>;\n    /**\n     * @name write (limitation on iOS, read below)\n     * Write a particular service's characteristic\n     * Note: no callback will occur on write without response on iOS.\n     * @param {WriteCharacteristicParams} params\n     * @returns {Promise<OperationResult>}\n     */\n    write(params: WriteCharacteristicParams): Promise<OperationResult>;\n    /**\n     * @name write (limitation on iOS, read below)\n     * Write Quick / Queue, use this method to quickly execute write without response commands when writing more than 20 bytes at a time.\n     * Note: no callback will occur on write without response on iOS.\n     * @param {WriteCharacteristicParams} params\n     * @returns {Promise<OperationResult>}\n     */\n    writeQ(params: WriteCharacteristicParams): Promise<OperationResult>;\n    /**\n     * @name readDescriptor\n     * Read a particular characterist's descriptor\n     * @param {OperationDescriptorParams} params\n     * @returns {Promise<DescriptorResult>}\n     */\n    readDescriptor(params: OperationDescriptorParams): Promise<DescriptorResult>;\n    /**\n     * @name writeDescriptor\n     * Write a particular characteristic's descriptor. Unable to write characteristic configuration directly to keep in line with iOS implementation.\n     * Instead use subscribe/unsubscribe, which will automatically enable/disable notification.\n     * @param {WriteDescriptorParams} params\n     * @returns {Promise<DescriptorResult>}\n     */\n    writeDescriptor(params: WriteDescriptorParams): Promise<DescriptorResult>;\n    /**\n     * @name rssi\n     * @param params.address\n     * Read RSSI of a connected device. RSSI is also returned with scanning.\n     * @param {{ address: string }} params\n     * @returns {Promise< RSSI >}\n     */\n    rssi(params: {\n        address: string;\n    }): Promise<RSSI>;\n    /**\n     * @name mtu (Android, Android 5+)\n     * @param params.address\n     * @param params.mtu\n     * Set MTU of a connected device. Android only.\n     * @param {{ address: string, mtu: number }} params\n     * @returns {Promise< MTU >}\n     */\n    mtu(params: {\n        address: string;\n        mtu?: number;\n    }): Promise<MTU>;\n    /**\n     * @name requestConnectionPriority (Android, Android 5+)\n     * @param params.address\n     * @param params.connectionPriority\n     * Request a change in the connection priority to improve throughput when transfer large amounts of data via BLE.\n     * Android support only. iOS will return error.\n     * @param {{ address: string, connectionPriority: ConnectionPriority }} params\n     * @returns {Promise<DeviceInfo>}\n     */\n    requestConnectionPriority(params: {\n        address: string;\n        connectionPriority: ConnectionPriority;\n    }): Promise<DeviceInfo>;\n    /**\n     * @name isInitialized\n     * Determine whether the adapter is initialized. No error callback. Returns true or false\n     * @returns {Promise<{ isInitialized: boolean }>}\n     */\n    isInitialized(): Promise<{\n        isInitialized: boolean;\n    }>;\n    /**\n     * @name isEnabled\n     * Determine whether the adapter is enabled. No error callback\n     * @returns {Promise<{ isEnabled: boolean }>}\n     */\n    isEnabled(): Promise<{\n        isEnabled: boolean;\n    }>;\n    /**\n     * @name isScanning\n     * Determine whether the adapter is scanning. No error callback. Returns true or false\n     * @returns {Promise<{ isScanning: boolean }>}\n     */\n    isScanning(): Promise<{\n        isScanning: boolean;\n    }>;\n    /**\n     * @name isBonded (Android)\n     * @param params.address\n     * Determine whether the device is bonded or not, or error if not initialized. Android support only.\n     * @param {{ address: string }} params\n     * @returns {Promise<BondedStatus>}\n     */\n    isBonded(params: {\n        address: string;\n    }): Promise<BondedStatus>;\n    /**\n     * @name wasConnected\n     * @param params.address\n     * Determine whether the device was connected, or error if not initialized.\n     * @param {{ address: string }} params\n     * @returns {Promise<PrevConnectionStatus>}\n     */\n    wasConnected(params: {\n        address: string;\n    }): Promise<PrevConnectionStatus>;\n    /**\n     * @name isConnected\n     * @param params.address\n     * Determine whether the device is connected, or error if not initialized or never connected to device\n     * @param {{ address: string }} params\n     * @returns {Promise<CurrConnectionStatus>}\n     */\n    isConnected(params: {\n        address: string;\n    }): Promise<CurrConnectionStatus>;\n    /**\n     * @name isDiscovered\n     * @param params.address\n     * Determine whether the device's characteristics and descriptors have been discovered, or error if not initialized or not connected to device.\n     * @param {{ address: string }} params\n     * @returns {Promise<DiscoverStatus>}\n     */\n    isDiscovered(params: {\n        address: string;\n    }): Promise<DiscoverStatus>;\n    /**\n     * @name hasPermission (useful only for Android 6+ / API 23)\n     * Determine whether coarse location privileges are granted since scanning for unpaired devices requires it in Android API 23\n     * @returns {Promise<{ hasPermission: boolean }>}\n     */\n    hasPermission(): Promise<{\n        hasPermission: boolean;\n    }>;\n    /**\n     * @name requestPermission (useful only for Android 6+ / API 23)\n     * Request coarse location privileges since scanning for unpaired devices requires it in Android API 23.\n     * Will return an error if called on iOS or Android versions prior to 6.0.\n     * @returns {Promise<{ requestPermission: boolean }>}\n     */\n    requestPermission(): Promise<{\n        requestPermission: boolean;\n    }>;\n    /**\n     * @name isLocationEnabled (useful only for Android 6+ / API 23)\n     * Determine if location services are enabled or not. Location Services are required to find devices in Android API 23\n     * @returns {Promise<{ isLocationEnabled: boolean }>}\n     */\n    isLocationEnabled(): Promise<{\n        isLocationEnabled: boolean;\n    }>;\n    /**\n     * @name requestLocation (useful only for Android 6+ / API 23)\n     * Prompt location services settings pages. requestLocation property returns whether location services are enabled or disabled.\n     * Location Services are required to find devices in Android API 23.\n     * @returns {Promise<{ requestLocation: boolean }>}\n     */\n    requestLocation(): Promise<{\n        requestLocation: boolean;\n    }>;\n    /**\n     * @name initializePeripheral\n     * Initialize Bluetooth on the device. Must be called before anything else.\n     * Callback will continuously be used whenever Bluetooth is enabled or disabled.\n     * @param {InitPeripheralParams} [params]\n     * @returns {Observable<InitializeResult>}\n     */\n    initializePeripheral(params?: InitPeripheralParams): Observable<InitializeResult>;\n    /**\n     * @name addService\n     * @param params.service\n     * @param params.characteristics\n     * Add a service with characteristics and descriptors. If more than one service is added, add them sequentially\n     * @param {{ service: string, characteristics: Characteristic[] }} params\n     * @returns {Promise<{ service: string, status: Status }>}\n     */\n    addService(params: {\n        service: string;\n        characteristics: Characteristic[];\n    }): Promise<{\n        service: string;\n        status: Status;\n    }>;\n    /**\n     * @name removeService\n     * @param params.service\n     * Remove a service\n     * @param {{ service: string }} params\n     * @returns {Promise<{ service: string, status: Status }>}\n     */\n    removeService(params: {\n        service: string;\n    }): Promise<{\n        service: string;\n        status: Status;\n    }>;\n    /**\n     * @name removeAllServices\n     * Remove all services\n     * @returns {Promise<{ status: Status }>}\n     */\n    removeAllServices(): Promise<{\n        status: Status;\n    }>;\n    /**\n     * @name startAdvertising (different behavior on Android/iOS, read below)\n     * Start advertising as a BLE device.\n     * Note: This needs to be improved so services can be used for both Android and iOS.\n     * On iOS, the advertising devices likes to rename itself back to the name of the device, i.e. Rand' iPhone\n     * @param {AdvertisingParams} params\n     * @returns {Promise<{ status: Status }>}\n     */\n    startAdvertising(params: AdvertisingParams): Promise<{\n        status: Status;\n    }>;\n    /**\n     * @name stopAdvertising\n     * Stop advertising\n     * @returns {Promise<{ status: Status }>}\n     */\n    stopAdvertising(): Promise<{\n        status: Status;\n    }>;\n    /**\n     * @name isAdvertising\n     * Determine if app is advertising or not.\n     * @returns {Promise<{ status: boolean }>}\n     */\n    isAdvertising(): Promise<{\n        status: boolean;\n    }>;\n    /**\n     * @name respond\n     * Respond to a read or write request\n     * @param {RespondParams} params\n     * @returns {Promise<{ status: Status }>}\n     */\n    respond(params: RespondParams): Promise<{\n        status: Status;\n    }>;\n    /**\n     * @name notify\n     * Update a value for a subscription. Currently all subscribed devices will receive update.\n     * Device specific updates will be added in the future.\n     * If sent equals false in the return value, you must wait for the peripheralManagerIsReadyToUpdateSubscribers event before sending more updates.\n     * @param {NotifyParams} params\n     * @returns {Promise<{ status: Status, sent: boolean }>}\n     */\n    notify(params: NotifyParams): Promise<{\n        status: Status;\n        sent: boolean;\n    }>;\n    /**\n     * @name encodedStringToBytes\n     * @param value\n     * Helper function to convert a base64 encoded string from a characteristic or descriptor value into a uint8Array object\n     * @param {string} str\n     * @returns {Uint8Array}\n     */\n    encodedStringToBytes(value: string): Uint8Array;\n    /**\n     * @name bytesToEncodedString\n     * @param value\n     * Helper function to convert a unit8Array to a base64 encoded string for a characteric or descriptor write\n     * @param {Uint8Array} bytes\n     * @returns {string}\n     */\n    bytesToEncodedString(value: Uint8Array): string;\n    /**\n     * @name stringToBytes\n     * Helper function to convert a string to bytes\n     * @param {string} value\n     * @returns {Uint8Array}\n     */\n    stringToBytes(value: string): Uint8Array;\n    /**\n     * @name bytesToString\n     * Helper function to convert bytes to a string.\n     * @param {Uint8Array} value\n     * @returns {string}\n     */\n    bytesToString(value: Uint8Array): string;\n    SCAN_MODE_OPPORTUNISTIC: number;\n    SCAN_MODE_LOW_POWER: number;\n    SCAN_MODE_BALANCED: number;\n    SCAN_MODE_LOW_LATENCY: number;\n    MATCH_MODE_AGGRESSIVE: number;\n    MATCH_MODE_STICKY: number;\n    MATCH_NUM_ONE_ADVERTISEMENT: number;\n    MATCH_NUM_FEW_ADVERTISEMENT: number;\n    MATCH_NUM_MAX_ADVERTISEMENT: number;\n    CALLBACK_TYPE_ALL_MATCHES: number;\n    CALLBACK_TYPE_FIRST_MATCH: number;\n    CALLBACK_TYPE_MATCH_LOST: number;\n}\n"]}